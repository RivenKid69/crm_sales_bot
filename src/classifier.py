"""
Гибридный классификатор интентов + извлечение данных

Архитектура:
1. Нормализация текста (TextNormalizer)
2. Быстрая проверка по корням слов (INTENT_ROOTS)
3. Если confidence < threshold → fallback на pymorphy2 (лемматизация)
4. Извлечение данных (company_size, pain_point, contact_info) через regex
"""

import re
import difflib
from typing import Dict, List, Tuple, Optional


# =============================================================================
# СЛОВАРИ ДЛЯ НОРМАЛИЗАЦИИ ТЕКСТА
# =============================================================================

# Словарь опечаток и разговорных форм → нормализованные варианты
TYPO_FIXES: Dict[str, str] = {
    # =================================================================
    # ЦЕНОВЫЕ СЛОВА
    # =================================================================
    "ценик": "ценник",
    "ценика": "ценника",
    "цена": "цена",
    "скока": "сколько",
    "скоко": "сколько",
    "скольк": "сколько",
    "почом": "почем",
    "почем": "почем",
    "скидон": "скидка",
    "скидос": "скидка",
    "прайс": "прайс",
    "прайслист": "прайс",
    "прайсик": "прайс",
    "тарифчик": "тариф",
    "тарифы": "тарифы",
    "стоимость": "стоимость",
    "стоит": "стоит",
    "денег": "денег",
    "деняг": "денег",
    "бабла": "денег",
    "бабло": "деньги",
    "бабок": "денег",

    # =================================================================
    # ПРИВЕТСТВИЯ И ПРОЩАНИЯ
    # =================================================================
    "прив": "привет",
    "превед": "привет",
    "приф": "привет",
    "прива": "привет",
    "привки": "привет",
    "хай": "привет",
    "хаюшки": "привет",
    "хеллоу": "привет",
    "здрасте": "здравствуйте",
    "здрасьте": "здравствуйте",
    "здаров": "здравствуйте",
    "здарова": "здравствуйте",
    "дратути": "здравствуйте",
    "доброго": "добрый",
    "добр": "добрый",
    "утречко": "утро",
    "вечерочек": "вечер",
    "денечек": "день",
    "пок": "пока",
    "покеда": "пока",
    "покедова": "пока",
    "бай": "пока",
    "бб": "пока",
    "удачки": "удачи",

    # =================================================================
    # РАЗГОВОРНЫЕ И СЛЕНГОВЫЕ
    # =================================================================
    "че": "что",
    "чо": "что",
    "шо": "что",
    "чего": "что",
    "чет": "что-то",
    "чето": "что-то",
    "чот": "что-то",
    "щас": "сейчас",
    "счас": "сейчас",
    "ща": "сейчас",
    "седня": "сегодня",
    "сегдня": "сегодня",
    "тока": "только",
    "ток": "только",
    "токо": "только",
    "тоже": "тоже",
    "тож": "тоже",
    "ваще": "вообще",
    "вапще": "вообще",
    "вобще": "вообще",
    "вопщем": "в общем",
    "короч": "короче",
    "кароч": "короче",
    "норм": "нормально",
    "нормик": "нормально",
    "ок": "хорошо",
    "окей": "хорошо",
    "океюшки": "хорошо",
    "лан": "ладно",
    "ладн": "ладно",
    "ладушки": "ладно",
    "спс": "спасибо",
    "спсб": "спасибо",
    "пасиб": "спасибо",
    "пасибо": "спасибо",
    "спасиб": "спасибо",
    "плз": "пожалуйста",
    "плиз": "пожалуйста",
    "пжлст": "пожалуйста",
    "пжл": "пожалуйста",
    "пж": "пожалуйста",
    "да": "да",
    "дап": "да",
    "ага": "да",
    "угу": "да",
    "ахах": "да",
    "не": "нет",
    "неа": "нет",
    "нет": "нет",
    "непа": "нет",
    "нету": "нет",
    "ну": "ну",
    "нуну": "ну",
    "типо": "типа",
    "типа": "типа",
    "оч": "очень",
    "ооч": "очень",
    "оооч": "очень",
    "канеш": "конечно",
    "канешна": "конечно",
    "конеш": "конечно",
    "наверн": "наверное",
    "наврн": "наверное",
    "мб": "может быть",
    "возм": "возможно",
    "возмжно": "возможно",

    # =================================================================
    # БИЗНЕС-ТЕРМИНЫ
    # =================================================================
    "црм": "crm",
    "срм": "crm",
    "црм": "crm",
    "црмка": "crm",
    "цээрэм": "crm",
    "битрик": "битрикс",
    "битрикс24": "битрикс",
    "амо": "амо",
    "амоцрм": "амо crm",
    "эксель": "excel",
    "эксел": "excel",
    "ексель": "excel",
    "табличка": "таблица",
    "табличку": "таблицу",
    "менеджр": "менеджер",
    "манагер": "менеджер",
    "сейлз": "менеджер по продажам",
    "сэйлз": "менеджер по продажам",
    "продажник": "менеджер по продажам",
    "клиентов": "клиентов",
    "клиентоф": "клиентов",
    "заявка": "заявка",
    "заявочка": "заявка",
    "лид": "лид",
    "лидик": "лид",
    "лидов": "лидов",
    "сделка": "сделка",
    "сделочка": "сделка",
    "контракт": "контракт",
    "договор": "договор",
    "дкп": "договор",

    # =================================================================
    # ЧИСЛИТЕЛЬНЫЕ И ЕДИНИЦЫ
    # =================================================================
    "чел": "человек",
    "челов": "человек",
    "человеек": "человек",
    "человк": "человек",
    "чвек": "человек",
    "сотр": "сотрудник",
    "сотрудн": "сотрудник",
    "штук": "штук",
    "шт": "штук",
    "руб": "рублей",
    "р": "рублей",
    "тыс": "тысяч",
    "к": "тысяч",
    "кк": "миллион",
    "млн": "миллион",
    "лям": "миллион",
    "мес": "месяц",
    "мсц": "месяц",

    # =================================================================
    # ВОПРОСИТЕЛЬНЫЕ
    # =================================================================
    "скажите": "скажите",
    "подскажте": "подскажите",
    "падскажите": "подскажите",
    "подскжите": "подскажите",
    "расскажте": "расскажите",
    "раскажите": "расскажите",

    # =================================================================
    # ОТРИЦАНИЯ И ВОЗРАЖЕНИЯ
    # =================================================================
    "дорга": "дорого",
    "дорага": "дорого",
    "доргао": "дорого",
    "дешево": "дешево",
    "дешивле": "дешевле",
    "интерсно": "интересно",
    "интиресно": "интересно",
    "неинтересно": "не интересно",
    "неинтерсно": "не интересно",
    "ненужно": "не нужно",
    "ненадо": "не надо",

    # =================================================================
    # СЛИПШИЕСЯ СЛОВА (основные)
    # =================================================================
    "сколькостоит": "сколько стоит",
    "какаяцена": "какая цена",
    "какойценник": "какой ценник",
    "скинутьпрайс": "скинуть прайс",
    "естьскидки": "есть скидки",
    "подскажитецену": "подскажите цену",
    "чтопочем": "что почем",
    "какиетарифы": "какие тарифы",
    "какстоимость": "как стоимость",
    "естьдемо": "есть демо",
    "хочудемо": "хочу демо",
    "хочупопробовать": "хочу попробовать",
    "давайтепопробуем": "давайте попробуем",
    "расскажитеподробнее": "расскажите подробнее",
    "ненужноспасибо": "не нужно спасибо",
    "нетспасибо": "нет спасибо",
    "даинтересно": "да интересно",
    "добрыйдень": "добрый день",
    "доброеутро": "доброе утро",
    "добрыйвечер": "добрый вечер",

    # =================================================================
    # РАСКЛАДКА КЛАВИАТУРЫ (латиница → кириллица)
    # =================================================================
    "ghbdtn": "привет",
    "ghbd": "привет",
    "plfhfcndeqnt": "здравствуйте",
    "lj,hsq ltym": "добрый день",
    "crjkmrj cnjbn": "сколько стоит",
    "wtyf": "цена",
    "ghfqc": "прайс",
    "ljhjuj": "дорого",
    "bynthtcyj": "интересно",
    "yt ye;yj": "не нужно",
    "cgfcb,j": "спасибо",
    "lf": "да",
    "ytn": "нет",
}

# Паттерны для разбиения слипшихся слов (regex)
SPLIT_PATTERNS: List[Tuple[str, str]] = [
    # Вопросы о цене
    (r'сколько(\w)', r'сколько \1'),
    (r'какая(\w)', r'какая \1'),
    (r'какой(\w)', r'какой \1'),
    (r'какие(\w)', r'какие \1'),
    (r'какую(\w)', r'какую \1'),

    # Глаголы
    (r'есть(\w)', r'есть \1'),
    (r'хочу(\w)', r'хочу \1'),
    (r'нужно(\w)', r'нужно \1'),
    (r'можно(\w)', r'можно \1'),
    (r'давайте(\w)', r'давайте \1'),
    (r'скинуть(\w)', r'скинуть \1'),
    (r'расскажите(\w)', r'расскажите \1'),
    (r'подскажите(\w)', r'подскажите \1'),

    # Приветствия
    (r'добрый(\w)', r'добрый \1'),
    (r'доброе(\w)', r'доброе \1'),
    (r'привет(\w)', r'привет \1'),

    # Отрицания
    (r'не(\w{3,})', r'не \1'),  # минимум 3 буквы после "не"
    (r'нет(\w{3,})', r'нет \1'),

    # Местоимения
    (r'что(\w{3,})', r'что \1'),
    (r'как(\w{3,})', r'как \1'),

    # Союзы и предлоги (минимум 3 буквы после)
    (r'да(\w{4,})', r'да \1'),
]


class TextNormalizer:
    """
    Нормализатор текста для русскоязычных сообщений

    Обрабатывает:
    - Регистр и пробелы
    - Ё → Е
    - Повторяющиеся буквы
    - Опечатки и сленг
    - Слипшиеся слова
    """

    def __init__(self):
        self.typo_fixes = TYPO_FIXES
        self.split_patterns = SPLIT_PATTERNS
        # Предкомпилированные regex для производительности
        self._compiled_splits = [(re.compile(p), r) for p, r in self.split_patterns]
        # Regex для повторяющихся букв (3+ подряд → 2)
        self._repeated_chars = re.compile(r'(.)\1{2,}')
        # Regex для множественных пробелов
        self._multiple_spaces = re.compile(r'\s+')

    def normalize(self, text: str) -> str:
        """
        Полная нормализация текста

        Этапы:
        1. lower() + strip()
        2. Ё → Е
        3. Убрать повторяющиеся буквы: "приииивет" → "привет"
        4. Убрать лишние пробелы
        5. Исправить слипшиеся слова
        6. Исправить опечатки

        Args:
            text: Исходный текст

        Returns:
            Нормализованный текст
        """
        if not text:
            return ""

        # 1. Базовая нормализация
        result = text.lower().strip()

        # 2. Ё → Е
        result = result.replace('ё', 'е')

        # 3. Убираем повторяющиеся буквы (3+ → 1, потом слово проверим)
        # Сначала сжимаем до 2 букв, потом до 1 если слово не в словаре
        result = self._reduce_repeated_chars(result)

        # 4. Нормализуем пробелы
        result = self._multiple_spaces.sub(' ', result).strip()

        # 5. Разбиваем слипшиеся слова (regex паттерны)
        result = self._apply_split_patterns(result)

        # 6. Исправляем опечатки (по словарю)
        result = self._fix_typos(result)

        # Финальная очистка пробелов
        result = self._multiple_spaces.sub(' ', result).strip()

        return result

    def _reduce_repeated_chars(self, text: str) -> str:
        """
        Убираем повторяющиеся буквы

        "приииивет" → "привет"
        "скооолько" → "сколько"
        "даааа" → "да"
        """
        # Сначала сжимаем 3+ повторов до 2
        result = self._repeated_chars.sub(r'\1\1', text)

        # Затем пробуем сжать до 1, если это даёт валидное слово
        words = result.split()
        normalized_words = []

        for word in words:
            # Пробуем варианты с одинарными буквами
            single_char = re.sub(r'(.)\1+', r'\1', word)

            # Если слово в словаре опечаток — берём его
            if single_char in self.typo_fixes:
                normalized_words.append(single_char)
            elif word in self.typo_fixes:
                normalized_words.append(word)
            else:
                # Пробуем single_char как более вероятный вариант
                # для русских слов двойные буквы редки
                normalized_words.append(single_char)

        return ' '.join(normalized_words)

    def _apply_split_patterns(self, text: str) -> str:
        """Применяем паттерны разбиения слипшихся слов"""
        result = text

        # Сначала проверяем полные слова в словаре
        words = result.split()
        fixed_words = []

        for word in words:
            # Если слово целиком есть в словаре опечаток — подставляем
            if word in self.typo_fixes:
                fixed_words.append(self.typo_fixes[word])
            else:
                fixed_words.append(word)

        result = ' '.join(fixed_words)

        # Затем применяем regex паттерны
        for pattern, replacement in self._compiled_splits:
            result = pattern.sub(replacement, result)

        return result

    def _fix_typos(self, text: str) -> str:
        """Исправляем опечатки по словарю"""
        words = text.split()
        fixed_words = []

        for word in words:
            # Убираем пунктуацию для поиска
            clean_word = re.sub(r'[^\w]', '', word)

            if clean_word in self.typo_fixes:
                # Сохраняем пунктуацию
                prefix = ''
                suffix = ''
                if word and not word[0].isalnum():
                    prefix = word[0]
                if word and not word[-1].isalnum():
                    suffix = word[-1]
                fixed_words.append(prefix + self.typo_fixes[clean_word] + suffix)
            else:
                fixed_words.append(word)

        return ' '.join(fixed_words)

    def fuzzy_match(self, word: str, targets: List[str], threshold: float = 0.75) -> Optional[str]:
        """
        Нечёткий поиск ближайшего слова

        Args:
            word: Искомое слово
            targets: Список целевых слов
            threshold: Минимальный порог схожести (0.0-1.0)

        Returns:
            Ближайшее слово если similarity >= threshold, иначе None
        """
        if not word or not targets:
            return None

        best_match = None
        best_ratio = 0.0

        for target in targets:
            ratio = difflib.SequenceMatcher(None, word.lower(), target.lower()).ratio()
            if ratio > best_ratio and ratio >= threshold:
                best_ratio = ratio
                best_match = target

        return best_match

    def suggest_correction(self, word: str, threshold: float = 0.7) -> Optional[str]:
        """
        Предлагает исправление для неизвестного слова

        Использует fuzzy matching по словарю опечаток
        """
        return self.fuzzy_match(word, list(self.typo_fixes.keys()), threshold)

try:
    from pymorphy3 import MorphAnalyzer
    PYMORPHY_AVAILABLE = True
except ImportError:
    try:
        from pymorphy2 import MorphAnalyzer
        PYMORPHY_AVAILABLE = True
    except ImportError:
        PYMORPHY_AVAILABLE = False
        MorphAnalyzer = None
        print("[WARNING] pymorphy2/pymorphy3 не установлен. Fallback на лемматизацию недоступен.")

from config import (
    INTENT_ROOTS,
    INTENT_PHRASES,
    CLASSIFIER_CONFIG
)


class RootClassifier:
    """Быстрая классификация по корням слов"""

    def __init__(self):
        self.roots = INTENT_ROOTS
        self.config = CLASSIFIER_CONFIG

    def classify(self, message: str) -> Tuple[str, float, Dict[str, int]]:
        """
        Классификация по корням

        Returns:
            (intent, confidence, scores_dict)
        """
        message_lower = message.lower()
        scores: Dict[str, int] = {}

        for intent, roots in self.roots.items():
            score = 0
            for root in roots:
                if root in message_lower:
                    score += 1
            if score > 0:
                scores[intent] = score

        if not scores:
            return "unclear", 0.0, {}

        # Находим лучший интент
        best_intent = max(scores, key=scores.get)
        best_score = scores[best_intent]

        # Нормализуем confidence
        # Чем больше совпадений, тем выше уверенность
        confidence = min(best_score * self.config["root_match_weight"] / 3, 1.0)

        # Бонус если есть явный лидер (разрыв с вторым местом)
        sorted_scores = sorted(scores.values(), reverse=True)
        if len(sorted_scores) > 1:
            gap = sorted_scores[0] - sorted_scores[1]
            if gap >= 2:
                confidence = min(confidence + 0.2, 1.0)

        return best_intent, confidence, scores


class LemmaClassifier:
    """Fallback классификация через pymorphy2"""

    def __init__(self):
        self.phrases = INTENT_PHRASES
        self.config = CLASSIFIER_CONFIG
        self.morph = MorphAnalyzer() if PYMORPHY_AVAILABLE else None

    def _lemmatize(self, text: str) -> List[str]:
        """Приводим слова к нормальной форме"""
        if not self.morph:
            return text.lower().split()

        words = re.findall(r'[а-яёa-z0-9]+', text.lower())
        lemmas = []
        for word in words:
            parsed = self.morph.parse(word)
            if parsed:
                lemmas.append(parsed[0].normal_form)
            else:
                lemmas.append(word)
        return lemmas

    def _lemmatize_phrase(self, phrase: str) -> str:
        """Лемматизируем фразу и склеиваем обратно"""
        return " ".join(self._lemmatize(phrase))

    def classify(self, message: str) -> Tuple[str, float, Dict[str, float]]:
        """
        Классификация через лемматизацию

        Returns:
            (intent, confidence, scores_dict)
        """
        if not PYMORPHY_AVAILABLE:
            return "unclear", 0.0, {}

        message_lemmas = self._lemmatize(message)
        message_lemma_str = " ".join(message_lemmas)

        scores: Dict[str, float] = {}

        for intent, phrases in self.phrases.items():
            best_match_score = 0.0

            for phrase in phrases:
                phrase_lemmas = self._lemmatize(phrase)
                phrase_lemma_str = " ".join(phrase_lemmas)

                # Точное совпадение лемматизированной фразы
                if phrase_lemma_str in message_lemma_str:
                    match_score = len(phrase_lemmas) * self.config["lemma_match_weight"]
                    best_match_score = max(best_match_score, match_score)
                    continue

                # Частичное совпадение (все леммы фразы есть в сообщении)
                matching_lemmas = sum(1 for l in phrase_lemmas if l in message_lemmas)
                if matching_lemmas == len(phrase_lemmas):
                    match_score = matching_lemmas * self.config["lemma_match_weight"] * 0.8
                    best_match_score = max(best_match_score, match_score)

            if best_match_score > 0:
                scores[intent] = best_match_score

        if not scores:
            return "unclear", 0.0, {}

        best_intent = max(scores, key=scores.get)
        best_score = scores[best_intent]

        # Нормализуем confidence
        confidence = min(best_score / 4, 1.0)

        return best_intent, confidence, scores


class DataExtractor:
    """Извлекаем структурированные данные из сообщения"""

    def extract(self, message: str, context: Dict = None) -> Dict:
        """
        Извлекаем данные из сообщения

        Args:
            message: Сообщение пользователя
            context: Контекст (missing_data, collected_data) для понимания коротких ответов
        """
        extracted = {}
        message_lower = message.lower().strip()
        context = context or {}
        missing_data = context.get("missing_data", [])

        # === Размер компании ===
        size_patterns = [
            r'(\d+)\s*(?:человек|чел\.?|менеджер|сотрудник|продаж)',
            r'нас\s*(\d+)',
            r'команд[аы]?\s*(?:из|в|на)?\s*(\d+)',
            r'отдел[еа]?\s*(\d+)',
            r'(\d+)\s*(?:в команде|в отделе|человек)',
            r'штат[еа]?\s*(\d+)',
            r'работа[ею]т?\s*(\d+)',
        ]
        for pattern in size_patterns:
            match = re.search(pattern, message_lower)
            if match:
                size = int(match.group(1))
                if 1 <= size <= 10000:
                    extracted["company_size"] = size
                    break

        # Контекстное извлечение: если просто число и спрашивали о размере
        if "company_size" not in extracted and "company_size" in missing_data:
            # Проверяем что сообщение — просто число (возможно со словами)
            just_number = re.match(r'^(\d+)\s*(?:человек|чел)?\.?$', message_lower)
            if just_number:
                size = int(just_number.group(1))
                if 1 <= size <= 10000:
                    extracted["company_size"] = size

        # === Боль клиента ===
        pain_patterns = {
            # =================================================================
            # ПОТЕРЯ КЛИЕНТОВ И ОТТОК
            # =================================================================
            r'теря[ею]м?\s*клиент': "потеря клиентов",
            r'клиент\w*\s*(?:ухо|уш[её]л|сбеж|ушли)': "клиенты уходят",
            r'(?:отток|утечк)\w*\s*клиент': "отток клиентов",
            r'клиент\w*\s*(?:недовольн|жалу|ругают)': "недовольные клиенты",
            r'не\s*(?:возвращ|удержива)\w*\s*клиент': "не удерживаем клиентов",
            r'уход\w*\s*клиент': "клиенты уходят",
            r'клиент\w*\s*(?:уход|теря|бег)': "клиенты уходят",
            r'(?:мало|нет)\s*повторн': "нет повторных продаж",
            r'не\s*(?:возвращаются|приходят\s*снова)': "клиенты не возвращаются",
            r'(?:потерял|упустил)\w*\s*(?:клиент|заказ|сделк)': "упускаем клиентов",

            # =================================================================
            # УПУЩЕННЫЕ СДЕЛКИ И ЛИДЫ
            # =================================================================
            r'упуска[ею]м?\s*(?:сделк|лид|заявк|клиент)?': "упускаем сделки",
            r'(?:сделк|лид|заявк)\w*\s*(?:теря|пропа|упуск)': "теряем заявки",
            r'(?:пропуск|теря)\w*\s*(?:заявк|лид|обращен)': "пропускаем заявки",
            r'заявк\w*\s*(?:не\s*)?(?:обрабат|отвеча)': "заявки не обрабатываются",
            r'(?:долго|медленно)\s*(?:отвеча|реагир)\w*\s*(?:на\s*)?(?:заявк|лид)?': "медленная обработка заявок",
            r'лид\w*\s*(?:остыва|протуха|умира)': "лиды остывают",
            r'(?:горяч|тёпл|тепл)\w*\s*(?:лид|клиент)\w*\s*(?:остыва|теря)': "теряем горячих клиентов",
            r'не\s*(?:дозванива|дозвон)': "не дозваниваемся",

            # =================================================================
            # ПРОБЛЕМЫ С МЕНЕДЖЕРАМИ
            # =================================================================
            r'забыва[ею]т?\s*(?:перезвон|позвон|задач|клиент)?': "забывают задачи",
            r'менеджер\w*\s*(?:не\s*)?(?:перезван|звон)': "менеджеры не перезванивают",
            r'менеджер\w*\s*(?:косяч|лажа|ошиба)': "ошибки менеджеров",
            r'менеджер\w*\s*(?:забыва|пропуска|теря)': "менеджеры забывают",
            r'менеджер\w*\s*(?:не\s*работа|халтур|ленят)': "менеджеры не работают",
            r'менеджер\w*\s*(?:увол|уш[её]л|ушли)': "уход менеджеров",
            r'(?:новый|нов\w*)\s*менеджер\w*\s*(?:долго|не\s*мо)': "адаптация менеджеров",
            r'пропуска[ею]т?\s*(?:задач|звонк|встреч)?': "пропускают задачи",
            r'не\s*перезванива': "не перезванивают",
            r'сотрудник\w*\s*(?:не\s*)?(?:работа|выполня)': "проблемы с сотрудниками",
            r'(?:саботаж|саботир)': "саботаж сотрудников",
            r'(?:текучк|текучест)\w*\s*кадр': "текучка кадров",

            # =================================================================
            # НЕТ КОНТРОЛЯ И ПРОЗРАЧНОСТИ
            # =================================================================
            r'нет\s*контрол': "нет контроля",
            r'не\s*(?:могу|можем)\s*контролир': "нет контроля",
            r'не\s*вид[и|е][мт]\s*(?:что|как|чем)?': "нет видимости",
            r'контроль\s*(?:за|над)?\s*(?:менеджер|продаж|сотрудник)': "контроль продаж",
            r'(?:не\s*)?(?:понима|зна)[юем]\s*(?:что|как|сколько)': "нет понимания процессов",
            r'(?:чёрн|черн)\w*\s*ящик': "чёрный ящик",
            r'не\s*(?:отслежива|трек|мониторим)': "нет отслеживания",
            r'(?:непрозрачн|непонятн)\w*\s*(?:процесс|работ)?': "непрозрачные процессы",
            r'(?:кто|что)\s*(?:делает|работает|занят)': "неясно кто чем занят",
            r'не\s*(?:знаю|понимаю)\s*(?:чем|что|как)': "нет понимания",

            # =================================================================
            # ХАОС В ДАННЫХ И ИНСТРУМЕНТАХ
            # =================================================================
            r'excel|эксел|табличк': "работа в Excel",
            r'гугл\s*(?:табли|докс)|google\s*(?:sheet|doc)': "работа в Google Docs",
            r'блокнот|записк|стикер': "записи в блокнотах",
            r'всё\s*в\s*голов': "всё в головах",
            r'нигде\s*не\s*(?:фикс|запис)': "ничего не фиксируется",
            r'разброс|раскидан': "данные разбросаны",
            r'хаос': "хаос в данных",
            r'беспоряд|бардак|бедлам': "беспорядок",
            r'(?:кажд|разн)\w*\s*(?:сво[йяеи]|по.своему|ведёт|ведет)': "каждый ведёт по-своему",
            r'по.своему\s*(?:вед|дела|работа)': "каждый ведёт по-своему",
            r'(?:вед[её]т|ведут)\w*\s*(?:\w+\s+)?по.своему': "каждый ведёт по-своему",
            r'нет\s*(?:единой|общей)\s*(?:базы|системы)': "нет единой базы",
            r'(?:разн|много)\w*\s*(?:систем|программ|инструмент)': "много разных систем",
            r'(?:информац|данн)\w*\s*(?:тер|пропа)': "данные теряются",
            r'(?:дубл|повтор)\w*\s*(?:данн|информ|ввод)': "дублирование данных",
            r'ручн\w*\s*(?:ввод|работ|труд)': "много ручной работы",

            # =================================================================
            # ДУБЛИ И ОШИБКИ
            # =================================================================
            r'дубл[иеяь]': "дубли клиентов",
            r'путаниц': "путаница в данных",
            r'ошиб[ко]': "ошибки в работе",
            r'(?:один|одного)\s*клиент\w*\s*(?:несколько|много|двое)': "дубли клиентов",
            r'(?:повторн|дважды)\w*\s*(?:звон|пиш|обраща)': "повторные обращения",
            r'(?:перепут|смеша|спута)': "путаница",
            r'(?:неточн|некорректн|неправильн)\w*\s*данн': "некорректные данные",
            r'(?:устарел|старые|неактуальн)\w*\s*(?:данн|информ|контакт)': "устаревшие данные",

            # =================================================================
            # ОБЩАЯ НЕЭФФЕКТИВНОСТЬ
            # =================================================================
            r'долго\s*(?:иск|наход)': "долго ищут информацию",
            r'не\s*успева[ею]': "не успевают",
            r'много\s*времен': "много времени на рутину",
            r'неэффективн': "неэффективность",
            r'медленн': "медленная работа",
            r'рутин': "много рутины",
            r'(?:убива|трат|жр[её]т)\w*\s*врем': "тратят много времени",
            r'(?:отнима|занима)\w*\s*(?:много\s*)?врем': "занимает много времени",
            r'(?:низк|плох)\w*\s*(?:производительн|эффективн)': "низкая эффективность",
            r'(?:простаива|просто[йи])': "простои в работе",
            r'(?:затягива|задержива|опаздыва)': "задержки",

            # =================================================================
            # ПРОДАЖИ
            # =================================================================
            r'плох\w*\s*продаж': "плохие продажи",
            r'слаб\w*\s*продаж': "слабые продажи",
            r'низк\w*\s*продаж': "низкие продажи",
            r'продаж[иа]?\s*(?:пада|упа|снижа|плох|низк)': "падение продаж",
            r'(?:пада|упа|снижа)\w*\s*продаж': "падение продаж",
            r'мало\s*(?:продаж|клиент|сделок)': "мало продаж",
            r'(?:увеличить|поднять|нарастить)\s*продаж': "рост продаж",
            r'проблем\w*\s*(?:с\s*)?продаж': "проблемы с продажами",
            r'(?:низк|плох|мал)\w*\s*конверси': "низкая конверсия",
            r'(?:мал|низк)\w*\s*(?:средн|чек|сумм)': "низкий средний чек",
            r'(?:длинн|долг)\w*\s*(?:цикл|сделк)': "длинный цикл сделки",
            r'не\s*(?:выполня|закрыва)\w*\s*план': "не выполняют план",
            r'план\w*\s*(?:не\s*)?(?:выполня|горит|срыва)': "срыв плана продаж",
            r'(?:выручк|доход|оборот)\w*\s*(?:пада|сниж|мал)': "падение выручки",
            r'(?:маржа|маржинальн|прибыл)\w*\s*(?:пада|сниж|мал|низк)': "низкая маржа",

            # =================================================================
            # АНАЛИТИКА И ОТЧЁТЫ
            # =================================================================
            r'нет\s*(?:статистик|аналитик|отчёт|отчет)': "нет аналитики",
            r'(?:хочу|нужн|надо)\s*(?:вид|знать)\w*\s*(?:статистик|цифр|показател)': "нужна аналитика",
            r'(?:не\s*)?(?:понима|зна)[юем]\s*(?:цифр|показател|статистик)': "непонятна статистика",
            r'(?:собира|формиру|делаю)\w*\s*отчёт\w*\s*(?:вручную|руками)': "ручные отчёты",
            r'отчёт\w*\s*(?:долго|сложно|трудно)': "сложные отчёты",
            r'(?:kpi|кпи|метрик)\w*\s*(?:нет|не\s*(?:счита|отслежива))': "нет KPI",
            r'воронк\w*\s*(?:не\s*)?(?:вид|отслежива|понима)': "не видим воронку",
            r'(?:прогноз|планирован)\w*\s*(?:нет|сложн|невозможн)': "нет прогнозирования",

            # =================================================================
            # КОММУНИКАЦИЯ И КОМАНДА
            # =================================================================
            r'(?:плох|нет)\w*\s*коммуникац': "плохая коммуникация",
            r'(?:не\s*)?(?:знаю|понима)[юем]\s*(?:что|как)\s*(?:делает|работает)\s*(?:коллег|команд)': "нет коммуникации в команде",
            r'(?:передач|переда[ёе])\w*\s*(?:клиент|дел|информац)': "проблемы с передачей дел",
            r'(?:команд|отдел)\w*\s*(?:не\s*)?(?:работа|координир)': "проблемы координации",
            r'(?:между\s*)?отдел\w*\s*(?:не\s*)?(?:взаимодейств|общ|коммуник)': "нет связи между отделами",
            r'(?:конфликт|спор|выясн)\w*\s*(?:менеджер|сотрудник)?': "конфликты в команде",

            # =================================================================
            # ЗВОНКИ И ТЕЛЕФОНИЯ
            # =================================================================
            r'звонк\w*\s*(?:тер|пропуск|пропада)': "теряем звонки",
            r'(?:пропущ|пропуска)\w*\s*звонк': "пропущенные звонки",
            r'(?:не\s*)?(?:записыва|сохраня)\w*\s*звонк': "не записываем звонки",
            r'(?:нет|не\s*вед[её])\w*\s*истор\w*\s*(?:звонк|общен|переговор)': "нет истории звонков",
            r'(?:не\s*)?(?:слуша|анализ)\w*\s*звонк': "не анализируем звонки",
            r'(?:скрипт|сценар)\w*\s*(?:нет|не\s*(?:работ|соблюд))': "нет скриптов продаж",

            # =================================================================
            # АВТОМАТИЗАЦИЯ И ПРОЦЕССЫ
            # =================================================================
            r'автоматизир': "автоматизация",
            r'систематизир': "систематизация",
            r'(?:навести|нужен)\s*порядок': "навести порядок",
            r'(?:оптимиз|улучш)\w*\s*процесс': "оптимизация процессов",
            r'(?:выстро|постро|настро)\w*\s*(?:процесс|систем|работ)': "выстроить процессы",
            r'(?:нет|отсутств)\w*\s*(?:процесс|регламент|стандарт)': "нет процессов",
            r'(?:всё|все)\s*(?:вручную|руками|делаем\s*вручную)': "всё делается вручную",
            r'(?:делаем|делают|работаем)\s*(?:всё\s*)?вручную': "всё делается вручную",
            r'(?:автоматич|автомат)\w*\s*(?:напоминан|задач|уведомлен)': "нужна автоматизация",
            r'(?:нужн|хотим|надо)\s*(?:crm|црм|систем)': "нужна CRM",
            r'(?:внедр|запуст)\w*\s*(?:crm|црм|систем)': "внедрение CRM",

            # =================================================================
            # МАСШТАБИРОВАНИЕ И РОСТ
            # =================================================================
            r'(?:не\s*)?(?:мож|получа)\w*\s*(?:масштаб|расти|вырасти)': "проблемы масштабирования",
            r'(?:рост|развити)\w*\s*(?:ограничен|невозможен|сложн)': "ограничения роста",
            r'(?:упир|упёрл|упер)\w*\s*(?:в\s*)?(?:потолок|стену|границ)': "упёрлись в потолок",
            r'(?:бизнес|компани)\w*\s*(?:не\s*)?(?:раст|развива)': "бизнес не растёт",
            r'(?:больше|много)\s*(?:клиент|заказ)\w*\s*(?:не\s*)?(?:справля|обрабат)': "не справляемся с потоком",

            # =================================================================
            # ЖЕЛАНИЯ И ПОТРЕБНОСТИ (косвенные)
            # =================================================================
            r'(?:хочу|хотим|нужн|надо)\s*(?:видеть|знать)\s*(?:статистик|аналитик|цифр)': "нужна аналитика",
            r'(?:хочу|хотим|нужн|надо)\s*(?:контролир|отслежива|мониторить)': "нужен контроль",
            r'(?:хочу|хотим|нужн|надо)\s*(?:понима|знать)\s*(?:что|как|где)': "нужна прозрачность",
            r'(?:хочу|хотим|нужн|надо)\s*(?:автоматиз|упростить|ускорить)': "нужна автоматизация",
            r'(?:хочу|хотим|нужн|надо)\s*(?:порядок|систем|структур)': "нужна систематизация",
            r'(?:хочу|хотим|нужн\w*|надо)\s+(?:един|общ)\w*\s+(?:баз|систем|место)': "нужна единая система",
            r'нужн\w*\s+(?:един|общ)\w*\s+баз': "нужна единая база",
            r'(?:един|общ)\w*\s+(?:баз|систем)\w*\s+(?:нет|нужн)': "нужна единая система",
            r'(?:устал|надоел)\w*\s*(?:от\s*)?(?:бардак|хаос|беспоряд|рутин)': "устали от хаоса",
            r'(?:хочу|хотим)\s*(?:как\s*у\s*)?(?:нормальн|взросл|больш)': "хотим нормальные процессы",

            # =================================================================
            # АБСТРАКТНЫЕ ЖАЛОБЫ
            # =================================================================
            r'всё\s*плохо': "всё плохо",
            r'ничего\s*не\s*работ': "ничего не работает",
            r'не\s*работает\s*(?:нормальн|как\s*надо)': "не работает нормально",
            r'полный\s*(?:бардак|хаос|трэш|треш|пипец|капец)': "полный бардак",
            r'(?:сплошн|одни)\s*(?:проблем|головн\w*\s*бол)': "сплошные проблемы",
            r'(?:замуч|задолб|достал)': "замучились",
            r'(?:невозможн|нереальн|нельзя)\s*(?:работ|так\s*дальше)': "невозможно работать",
            r'(?:тонем|зашива|захлёб)': "захлёбываемся",
            r'(?:горим|пожар|срочн|аврал)': "постоянные авралы",
        }

        for pattern, pain in pain_patterns.items():
            if re.search(pattern, message_lower):
                extracted["pain_point"] = pain
                break

        # Контекстное: если спрашивали о проблемах, а клиент ответил коротко
        if "pain_point" not in extracted and "pain_point" in missing_data:
            # Короткие ответы о сфере деятельности = проблема в этой сфере
            short_answers = {
                # =================================================================
                # СФЕРЫ ДЕЯТЕЛЬНОСТИ
                # =================================================================
                # Продажи
                "продажи": "улучшение продаж",
                "продажами": "улучшение продаж",
                "сейлз": "улучшение продаж",
                "sales": "улучшение продаж",

                # Маркетинг
                "маркетинг": "маркетинг и лиды",
                "маркетингом": "маркетинг и лиды",
                "реклама": "работа с рекламой",
                "рекламой": "работа с рекламой",
                "трафик": "управление трафиком",
                "трафиком": "управление трафиком",
                "лидогенерация": "генерация лидов",

                # Клиенты
                "клиенты": "работа с клиентами",
                "клиентами": "работа с клиентами",
                "заказчики": "работа с заказчиками",
                "заказчиками": "работа с заказчиками",
                "покупатели": "работа с покупателями",

                # HR и персонал
                "hr": "управление персоналом",
                "кадры": "работа с кадрами",
                "персонал": "управление персоналом",
                "персоналом": "управление персоналом",
                "сотрудники": "управление сотрудниками",
                "сотрудниками": "управление сотрудниками",
                "менеджеры": "контроль менеджеров",
                "менеджерами": "контроль менеджеров",

                # Логистика и склад
                "логистика": "управление логистикой",
                "логистикой": "управление логистикой",
                "доставка": "управление доставкой",
                "доставкой": "управление доставкой",
                "склад": "учёт склада",
                "складом": "учёт склада",

                # Финансы
                "финансы": "финансовый учёт",
                "финансами": "финансовый учёт",
                "деньги": "учёт финансов",
                "деньгами": "учёт финансов",
                "оплаты": "контроль оплат",
                "оплатами": "контроль оплат",
                "дебиторка": "контроль дебиторки",
                "дебиторкой": "контроль дебиторки",

                # =================================================================
                # ДЕЙСТВИЯ И ПРОЦЕССЫ
                # =================================================================
                # Коммуникации
                "звонки": "учёт звонков",
                "звонками": "учёт звонков",
                "переговоры": "ведение переговоров",
                "переговорами": "ведение переговоров",
                "общение": "коммуникация с клиентами",
                "общением": "коммуникация с клиентами",
                "переписка": "ведение переписки",
                "перепиской": "ведение переписки",

                # Заявки и лиды
                "заявки": "обработка заявок",
                "заявками": "обработка заявок",
                "лиды": "обработка лидов",
                "лидами": "обработка лидов",
                "обращения": "обработка обращений",
                "обращениями": "обработка обращений",
                "запросы": "обработка запросов",
                "запросами": "обработка запросов",

                # Сделки
                "сделки": "ведение сделок",
                "сделками": "ведение сделок",
                "заказы": "обработка заказов",
                "заказами": "обработка заказов",
                "договоры": "ведение договоров",
                "договорами": "ведение договоров",
                "контракты": "ведение контрактов",

                # Задачи
                "задачи": "управление задачами",
                "задачами": "управление задачами",
                "дела": "управление делами",
                "делами": "управление делами",
                "напоминания": "система напоминаний",
                "напоминаниями": "система напоминаний",

                # =================================================================
                # УЧЁТ И ОТЧЁТНОСТЬ
                # =================================================================
                "учёт": "учёт клиентов",
                "учет": "учёт клиентов",
                "учётом": "учёт клиентов",
                "учетом": "учёт клиентов",
                "контроль": "контроль менеджеров",
                "контролем": "контроль менеджеров",
                "отчёты": "отчётность",
                "отчеты": "отчётность",
                "отчётами": "отчётность",
                "отчетами": "отчётность",
                "отчётность": "отчётность",
                "отчетность": "отчётность",
                "аналитика": "аналитика продаж",
                "аналитикой": "аналитика продаж",
                "статистика": "статистика продаж",
                "статистикой": "статистика продаж",
                "метрики": "отслеживание метрик",
                "kpi": "контроль KPI",
                "кпи": "контроль KPI",

                # Воронка
                "воронка": "воронка продаж",
                "воронкой": "воронка продаж",
                "конверсия": "повышение конверсии",
                "конверсией": "повышение конверсии",

                # =================================================================
                # СОСТОЯНИЯ И ПРОБЛЕМЫ
                # =================================================================
                "бардак": "наведение порядка",
                "хаос": "устранение хаоса",
                "беспорядок": "наведение порядка",
                "путаница": "устранение путаницы",
                "неразбериха": "устранение неразберихи",
                "каша": "наведение порядка",

                # Потери
                "потери": "сокращение потерь",
                "потерями": "сокращение потерь",
                "упущения": "сокращение упущений",
                "утечки": "устранение утечек",

                # Эффективность
                "эффективность": "повышение эффективности",
                "эффективностью": "повышение эффективности",
                "производительность": "повышение производительности",
                "скорость": "увеличение скорости работы",
                "скоростью": "увеличение скорости работы",
                "оптимизация": "оптимизация процессов",
                "оптимизацией": "оптимизация процессов",

                # Автоматизация
                "автоматизация": "автоматизация процессов",
                "автоматизацией": "автоматизация процессов",
                "систематизация": "систематизация работы",
                "систематизацией": "систематизация работы",

                # =================================================================
                # ИНСТРУМЕНТЫ И БАЗА
                # =================================================================
                "база": "ведение базы клиентов",
                "базой": "ведение базы клиентов",
                "crm": "внедрение CRM",
                "црм": "внедрение CRM",
                "система": "внедрение системы",
                "системой": "внедрение системы",
                "excel": "уход от Excel",
                "эксель": "уход от Excel",
                "экселем": "уход от Excel",
                "таблицы": "уход от таблиц",
                "таблицами": "уход от таблиц",
            }
            if message_lower in short_answers:
                extracted["pain_point"] = short_answers[message_lower]

        # === Контактная информация ===
        # Email
        email_match = re.search(r'[\w\.-]+@[\w\.-]+\.\w{2,}', message)
        if email_match:
            extracted["contact_info"] = email_match.group(0)

        # Телефон (если email не найден)
        if "contact_info" not in extracted:
            phone_patterns = [
                r'\+7[\s\-]?\(?\d{3}\)?[\s\-]?\d{3}[\s\-]?\d{2}[\s\-]?\d{2}',
                r'8[\s\-]?\(?\d{3}\)?[\s\-]?\d{3}[\s\-]?\d{2}[\s\-]?\d{2}',
                r'\d{3}[\s\-]?\d{3}[\s\-]?\d{2}[\s\-]?\d{2}',
            ]
            for pattern in phone_patterns:
                phone_match = re.search(pattern, message)
                if phone_match:
                    extracted["contact_info"] = phone_match.group(0).strip()
                    break

        # === Имя клиента ===
        name_patterns = [
            r'(?:меня\s*зовут|я\s+)\s*([А-ЯЁ][а-яё]+)',
            r'(?:это\s+)?([А-ЯЁ][а-яё]+)\s*(?:на связи|пишу|беспокоит)',
        ]
        for pattern in name_patterns:
            name_match = re.search(pattern, message)
            if name_match:
                extracted["client_name"] = name_match.group(1)
                break

        return extracted


class HybridClassifier:
    """
    Гибридный классификатор: быстрый + точный

    1. Нормализация текста (TextNormalizer)
    2. Пробуем быструю классификацию по корням
    3. Если confidence >= threshold → возвращаем
    4. Иначе → fallback на pymorphy2
    5. Выбираем лучший результат
    """

    def __init__(self):
        self.normalizer = TextNormalizer()
        self.root_classifier = RootClassifier()
        self.lemma_classifier = LemmaClassifier()
        self.data_extractor = DataExtractor()
        self.config = CLASSIFIER_CONFIG

    def classify(self, message: str, context: Dict = None) -> Dict:
        """
        Полная классификация сообщения

        Args:
            message: Сообщение пользователя
            context: Контекст диалога (missing_data, collected_data)

        Returns:
            {
                "intent": str,
                "confidence": float,
                "extracted_data": dict,
                "method": str  # "root" | "lemma" | "data"
            }
        """
        # 0. Нормализация текста (опечатки, слипшиеся слова, ё→е и т.д.)
        message = self.normalizer.normalize(message)

        # 1. Извлекаем данные (с учётом контекста)
        extracted = self.data_extractor.extract(message, context)

        # Если есть данные — это info_provided (высокий приоритет)
        if extracted.get("company_size") or extracted.get("pain_point"):
            return {
                "intent": "info_provided",
                "confidence": 0.95,
                "extracted_data": extracted,
                "method": "data"
            }

        # Если есть контакт — contact_provided
        if extracted.get("contact_info"):
            return {
                "intent": "contact_provided",
                "confidence": 0.95,
                "extracted_data": extracted,
                "method": "data"
            }

        # 2. Быстрая классификация по корням
        root_intent, root_conf, root_scores = self.root_classifier.classify(message)

        # Если уверенность высокая — возвращаем сразу
        if root_conf >= self.config["high_confidence_threshold"]:
            return {
                "intent": root_intent,
                "confidence": root_conf,
                "extracted_data": extracted,
                "method": "root",
                "debug_scores": root_scores
            }

        # 3. Fallback на лемматизацию
        lemma_intent, lemma_conf, lemma_scores = self.lemma_classifier.classify(message)

        # 4. Выбираем лучший результат
        if lemma_conf > root_conf:
            return {
                "intent": lemma_intent,
                "confidence": lemma_conf,
                "extracted_data": extracted,
                "method": "lemma",
                "debug_scores": lemma_scores
            }

        # Если оба метода дали низкую уверенность
        if root_conf < self.config["min_confidence"]:
            return {
                "intent": "unclear",
                "confidence": root_conf,
                "extracted_data": extracted,
                "method": "root",
                "debug_scores": root_scores
            }

        return {
            "intent": root_intent,
            "confidence": root_conf,
            "extracted_data": extracted,
            "method": "root",
            "debug_scores": root_scores
        }


# =============================================================================
# ТЕСТИРОВАНИЕ
# =============================================================================


def test_normalizer() -> bool:
    """Тест нормализатора текста"""
    n = TextNormalizer()

    tests = [
        # (input, expected_output)

        # Повторы букв
        ("приииивет", "привет"),
        ("скооолько стоооит", "сколько стоит"),
        ("даааа", "да"),
        ("неееет", "нет"),

        # Опечатки
        ("скока стоит", "сколько стоит"),
        ("ценик какой", "ценник какой"),
        ("прайслист скинь", "прайс скинь"),
        ("чё почём", "что почем"),

        # Слипшиеся слова
        ("сколькостоит", "сколько стоит"),
        ("какаяцена", "какая цена"),

        # Ё → Е
        ("подскажёте", "подскажете"),
        ("почём", "почем"),

        # Комбинированные
        ("приииив скока ценик", "привет сколько ценник"),
        ("здрааасте какаяцена", "здравствуйте какая цена"),

        # Приветствия с опечатками
        ("хаюшки", "привет"),
        ("здрасте", "здравствуйте"),
        ("дратути", "здравствуйте"),

        # Разговорные формы
        ("щас посмотрю", "сейчас посмотрю"),
        ("норм всё", "нормально все"),
        ("спс за инфу", "спасибо за инфу"),

        # Не должно ломать нормальный текст
        ("привет как дела", "привет как дела"),
        ("сколько стоит на 10 человек", "сколько стоит на 10 человек"),
        ("добрый день", "добрый день"),
    ]

    passed = 0
    for inp, expected in tests:
        result = n.normalize(inp)
        status = "✓" if result == expected else "✗"
        if result == expected:
            passed += 1
        else:
            print(f"{status} '{inp}' → '{result}' (ожидали: '{expected}')")

    print(f"\nНормализатор: {passed}/{len(tests)} тестов пройдено")
    return passed == len(tests)


def test_classifier() -> bool:
    """Тест классификатора (существующие тесты)"""
    classifier = HybridClassifier()

    test_cases = [
        # Приветствия
        ("Привет!", "greeting"),
        ("Здравствуйте, подскажите пожалуйста", "greeting"),
        ("Добрый день", "greeting"),

        # Вопросы о цене (разные формулировки)
        ("Сколько стоит?", "price_question"),
        ("Какая цена?", "price_question"),
        ("Подскажите по стоимости", "price_question"),
        ("Ценник какой?", "price_question"),
        ("А прайс есть?", "price_question"),
        ("Какие тарифы?", "price_question"),
        ("Во сколько обойдётся?", "price_question"),

        # Возражения
        ("Дорого", "objection_price"),
        ("Слишком дорого для нас", "objection_price"),
        ("Нет бюджета на это", "objection_price"),
        ("Нет времени сейчас", "objection_no_time"),
        ("Занят, перезвоните позже", "objection_no_time"),
        ("У нас уже есть CRM", "objection_competitor"),
        ("Используем Битрикс24", "objection_competitor"),

        # Согласие
        ("Да, интересно", "agreement"),
        ("Давайте попробуем", "agreement"),
        ("Расскажите подробнее", "agreement"),
        ("Хочу демо", "agreement"),

        # Отказ
        ("Не интересно", "rejection"),
        ("Нет, спасибо", "rejection"),
        ("Не нужно", "rejection"),

        # Данные
        ("У нас 15 человек в отделе", "info_provided"),
        ("Постоянно теряем клиентов", "info_provided"),
        ("Работаем в Excel, всё теряется", "info_provided"),
        ("Мой email: test@company.ru", "contact_provided"),
        ("+7 999 123-45-67", "contact_provided"),
    ]

    passed = 0
    failed = 0

    for message, expected in test_cases:
        result = classifier.classify(message)
        actual = result["intent"]
        conf = result["confidence"]
        method = result["method"]

        status = "✓" if actual == expected else "✗"
        if actual == expected:
            passed += 1
        else:
            failed += 1
            print(f"{status} '{message}'")
            print(f"   Ожидали: {expected}, Получили: {actual} ({conf:.2f}) [{method}]")
            if result.get("extracted_data"):
                print(f"   Данные: {result['extracted_data']}")

    print(f"\nКлассификатор: {passed}/{passed+failed} тестов пройдено")
    return passed == len(test_cases)


def test_full_pipeline() -> bool:
    """Тест полного пайплайна: нормализация → классификация → извлечение"""
    classifier = HybridClassifier()

    tests = [
        # (message, expected_intent, expected_data_key, expected_data_value)

        # Опечатки в вопросах о цене
        ("скока стоит", "price_question", None, None),
        ("ценик какой", "price_question", None, None),
        ("прайсик скиньте", "price_question", None, None),
        ("скока ваш прайс", "price_question", None, None),

        # Приветствия с ошибками
        ("приииивет", "greeting", None, None),
        ("здрааасте", "greeting", None, None),
        ("хаюшки", "greeting", None, None),
        ("дратути", "greeting", None, None),

        # Слипшиеся слова
        ("сколькостоит", "price_question", None, None),
        ("какаяцена", "price_question", None, None),

        # Данные с опечатками (размер команды)
        ("у нас 15 чел", "info_provided", "company_size", 15),
        ("команда 8 человеек", "info_provided", "company_size", 8),

        # Боли с опечатками
        ("менеджеры забыыывают звонить", "info_provided", "pain_point", "забывают задачи"),
        ("теряеем клиентов", "info_provided", "pain_point", "потеря клиентов"),

        # Возражения с опечатками
        ("дорга очень", "objection_price", None, None),
        ("дорага для нас", "objection_price", None, None),

        # Нормальные сообщения (не должны ломаться)
        ("сколько стоит на 10 человек", "info_provided", "company_size", 10),
        ("привет", "greeting", None, None),
        ("дорого", "objection_price", None, None),
        ("да, интересно", "agreement", None, None),
        ("какая цена", "price_question", None, None),
    ]

    passed = 0
    for msg, exp_intent, exp_key, exp_value in tests:
        result = classifier.classify(msg)

        intent_ok = result["intent"] == exp_intent
        data_ok = True
        if exp_key:
            data_ok = result.get("extracted_data", {}).get(exp_key) == exp_value

        if intent_ok and data_ok:
            passed += 1
        else:
            print(f"✗ '{msg}'")
            print(f"   Ожидали: intent={exp_intent}, {exp_key}={exp_value}")
            print(f"   Получили: intent={result['intent']}, data={result.get('extracted_data')}")

    print(f"\nПолный пайплайн: {passed}/{len(tests)} тестов пройдено")
    return passed == len(tests)


if __name__ == "__main__":
    print("=" * 60)
    print("ТЕСТИРОВАНИЕ КЛАССИФИКАТОРА")
    print("=" * 60)

    # 1. Тест нормализатора
    print("\n### ТЕСТ НОРМАЛИЗАТОРА ###\n")
    norm_ok = test_normalizer()

    # 2. Тест классификатора (существующие тесты)
    print("\n### ТЕСТ КЛАССИФИКАТОРА ###\n")
    class_ok = test_classifier()

    # 3. End-to-end тест
    print("\n### END-TO-END ТЕСТ ###\n")
    e2e_ok = test_full_pipeline()

    # Итог
    print("\n" + "=" * 60)
    all_passed = norm_ok and class_ok and e2e_ok
    if all_passed:
        print("✓ ВСЕ ТЕСТЫ ПРОЙДЕНЫ")
    else:
        print("✗ ЕСТЬ ОШИБКИ")
        if not norm_ok:
            print("  - Ошибки в нормализаторе")
        if not class_ok:
            print("  - Ошибки в классификаторе")
        if not e2e_ok:
            print("  - Ошибки в end-to-end тестах")
    print("=" * 60)
